/* TrixTech s.r.o. @2026 */

(function () {
  const CONFIG = {
    styleId: 'vf-translate-dynamic-style',
    defaultLang: 'cs',
    chatId: 'voiceflow-chat',
  };

  const TRANSLATIONS = {
    cs: {
      cssVars: {
        '--btn-start-text': '"Spustit nov칳 chat"',
        '--btn-cancel-text': '"Zru코it"',
        '--subheader-title-text': '"Poznejte m캩sto Litovel"',
        '--subheader-desc-text': '"prost콏ednictv칤m na코eho AI asistenta"',
        '--system-status-text': '"Chat byl ukon캜en"',
        '--ai-badge-text': '"Odpov캩캞 byla generov치na pomoc칤 AI"',
      },
      attributes: {
        placeholder: 'Napi코te v치코 dotaz...',
        sendTitle: 'Odeslat',
        openTitle: 'Otev콏칤t chat',
        closeTitle: 'Zav콏칤t chat',
        bannerLabel: 'Zvolen칳 jazyk je: 游뻟릖 캛e코tina',
      },
    },
    en: {
      cssVars: {
        '--btn-start-text': '"Start new chat"',
        '--btn-cancel-text': '"Cancel"',
        '--subheader-title-text': '"Discover the city of Litovel"',
        '--subheader-desc-text': '"through our AI assistant"',
        '--system-status-text': '"Chat has ended"',
        '--ai-badge-text': '"The response was generated by AI"',
      },
      attributes: {
        placeholder: 'Type your message...',
        sendTitle: 'Send',
        openTitle: 'Open chat',
        closeTitle: 'Close chat',
        bannerLabel: 'Language in use: 游쥟릖 English',
      },
    },
  };

  let currentLang = null;

  const WidgetTranslator = {
    getLanguage(trace) {
      let incoming = trace.payload?.lang || CONFIG.defaultLang;
      if (typeof incoming === 'object' && incoming !== null) {
        incoming = incoming.lang || incoming.language || CONFIG.defaultLang;
      }
      const cleanLang = String(incoming).toLowerCase().trim();
      if (cleanLang.match(/en|english/)) return 'en';
      if (cleanLang.match(/cs|cz|czech|cesky/)) return 'cs';
      return null;
    },

    getAllStyleRoots() {
      const roots = [document];
      const vfChat = document.getElementById(CONFIG.chatId);
      if (!vfChat?.shadowRoot) return roots;
      roots.push(vfChat.shadowRoot);
      const walker = (root) => {
        root.querySelectorAll('*').forEach((el) => {
          if (el.shadowRoot) {
            roots.push(el.shadowRoot);
            walker(el.shadowRoot);
          }
        });
      };
      walker(vfChat.shadowRoot);
      return roots;
    },

    teardown() {
      if (window._vfAttributeObserver) {
        window._vfAttributeObserver.disconnect();
        window._vfAttributeObserver = null;
      }
      this.getAllStyleRoots().forEach((root) => {
        if (!root) return;
        const styleEl = root.getElementById
          ? root.getElementById(CONFIG.styleId)
          : root.querySelector(`#${CONFIG.styleId}`);
        if (styleEl) styleEl.remove();
      });
      currentLang = null;
      window._currentTranslateLang = null;
    },

    injectGlobalStyles(lang) {
      if (!TRANSLATIONS[lang]) return;
      const data = TRANSLATIONS[lang].cssVars;
      let cssContent = ':host, :root, [id="voiceflow-chat"], body {\n';
      for (const [key, value] of Object.entries(data)) {
        cssContent += `  ${key}: ${value} !important;\n`;
      }
      cssContent += '}\n';
      cssContent += `
        button.vfrc-button[label="Start new chat"]::before,
        :is(button.vfrc-button[label="Start new chat"], #vfrc-start-chat)::before {
          content: ${data['--btn-start-text']} !important;
        }
        button.vfrc-button[label="Cancel"]::before {
          content: ${data['--btn-cancel-text']} !important;
        }
      `;
      const applyToRoot = (root) => {
        if (!root || !root.appendChild) return;
        let styleEl = root.getElementById?.(CONFIG.styleId);
        if (!styleEl) {
          styleEl = document.createElement('style');
          styleEl.id = CONFIG.styleId;
          const target = root.head || root;
          target.insertBefore(styleEl, target.firstChild);
        }
        if (styleEl.textContent !== cssContent) {
          styleEl.textContent = cssContent;
        }
      };
      this.getAllStyleRoots().forEach(applyToRoot);
    },

    updateAttributes(lang) {
      if (!TRANSLATIONS[lang]) return;
      const texts = TRANSLATIONS[lang].attributes;
      const vfChat = document.getElementById(CONFIG.chatId);
      const updateRootElements = (root) => {
        root.querySelectorAll('textarea.vfrc-chat-input').forEach((el) => {
          if (el.placeholder !== texts.placeholder) {
            el.placeholder = texts.placeholder;
          }
        });
        root
          .querySelectorAll('button[id="vfrc-send-message"]')
          .forEach((btn) => {
            if (btn.title !== texts.sendTitle) {
              btn.title = texts.sendTitle;
              btn.setAttribute('aria-label', texts.sendTitle);
            }
          });
        root
          .querySelectorAll('.vfrc-launcher, button.vfrc-launcher')
          .forEach((btn) => {
            const currentTitle =
              btn.title || btn.getAttribute('aria-label') || '';
            if (currentTitle.match(/Open|Otev콏칤t/i)) {
              if (btn.title !== texts.openTitle) {
                btn.title = texts.openTitle;
                btn.setAttribute('aria-label', texts.openTitle);
              }
            } else if (currentTitle.match(/Close|Zav콏칤t/i)) {
              if (btn.title !== texts.closeTitle) {
                btn.title = texts.closeTitle;
                btn.setAttribute('aria-label', texts.closeTitle);
              }
            }
          });
      };
      updateRootElements(document);
      if (vfChat?.shadowRoot) {
        updateRootElements(vfChat.shadowRoot);
      }
    },

    setupReactiveObserver() {
      if (window._vfAttributeObserver) return;
      let debounceTimer = 0;
      const observer = new MutationObserver(() => {
        const lang = window._currentTranslateLang;
        if (!lang || !TRANSLATIONS[lang]) return;
        if (debounceTimer) clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => {
          debounceTimer = 0;
          this.updateAttributes(lang);
          this.injectGlobalStyles(lang);
        }, 150);
      });
      const config = { childList: true, subtree: true };
      observer.observe(document.body, config);
      const vfChat = document.getElementById(CONFIG.chatId);
      if (vfChat?.shadowRoot) {
        observer.observe(vfChat.shadowRoot, config);
      }
      window._vfAttributeObserver = observer;
    },

    renderBanner(element, lang) {
      if (!TRANSLATIONS[lang]) {
        element.innerHTML = '';
        return;
      }
      const label = TRANSLATIONS[lang].attributes.bannerLabel;
      const container = document.createElement('div');
      container.className =
        'vfrc-message vfrc-message--extension TranslateWidget';
      container.innerHTML = `
        <style>
          .vfrc-message.vfrc-message--extension.TranslateWidget {
            opacity: 1;
            width: 100%;
            display: block;
          }
          .translate-box {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            width: 100%;
            box-sizing: border-box;
            background-color: #F9FAFB;
            border-radius: 12px;
            border: 1px solid #E5E7EB;
          }
          .translate-text {
            flex: 1;
            color: rgba(26, 30, 35, 0.7);
            font-size: 12px;
            font-family: var(--_1bof89na, sans-serif);
            font-style: italic;
          }
        </style>
        <div class="translate-box">
          <span class="translate-text">${label}</span>
        </div>
      `;
      element.innerHTML = '';
      element.appendChild(container);
    },

    setLanguage(lang) {
      if (!lang || !TRANSLATIONS[lang]) {
        this.teardown();
        return;
      }
      window._currentTranslateLang = lang;
      currentLang = lang;
      this.injectGlobalStyles(lang);
      this.updateAttributes(lang);
      this.setupReactiveObserver();
    },

    init(defaultLang) {
      const lang = this.getLanguage({
        payload: { lang: defaultLang ?? CONFIG.defaultLang },
      });
      this.setLanguage(lang);
      if (lang) {
        let attempts = 0;
        const maxAttempts = 20;
        const tryInject = () => {
          const current = window._currentTranslateLang;
          if (!current) return;
          this.injectGlobalStyles(current);
          this.updateAttributes(current);
          attempts++;
          if (attempts < maxAttempts) {
            setTimeout(tryInject, 300);
          }
        };
        setTimeout(tryInject, 500);
        setTimeout(tryInject, 1500);
      }
    },
  };

  window.TranslateWidget = {
    name: 'TranslateWidget',
    type: 'response',
    setLanguage: (lang) => WidgetTranslator.setLanguage(lang),
    init: (lang) => WidgetTranslator.init(lang),
    match: ({ trace }) =>
      trace.type === 'ext_translateWidget' ||
      trace.payload?.name === 'ext_translateWidget',
    render: ({ trace, element }) => {
      const lang = WidgetTranslator.getLanguage(trace);
      if (!lang) {
        WidgetTranslator.teardown();
        element.innerHTML = '';
        return;
      }
      if (window._currentTranslateLang === lang) {
        WidgetTranslator.renderBanner(element, lang);
        return;
      }
      WidgetTranslator.setLanguage(lang);
      WidgetTranslator.renderBanner(element, lang);
    },
  };
})();
